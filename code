<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retreat Resource Scheduler</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Firebase Libraries (Optional, kept from your script) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, addDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        // --- IMPORTANT: FIREBASE SETUP ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const appId = typeof __app_id !== 'undefined' ? 'default-app-id' : 'default-app-id';

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        setLogLevel('debug');

        // --- GLOBAL STATE ---
        window.db = db;
        window.auth = auth;
        window.appId = appId;
        window.userId = null;
        
        // --- AUTHENTICATION ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                console.log("User is signed in:", user.uid);
                window.userId = user.uid;
            } else {
                console.log("User is signed out. Attempting to sign in.");
                try {
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Error during sign-in:", error);
                    document.getElementById('status').innerText = 'Error: Could not authenticate with the database.';
                }
            }
        });

    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
    </style>
</head>
<body class="bg-gray-50 flex items-center justify-center min-h-screen">

    <div class="bg-white p-8 rounded-2xl shadow-lg max-w-lg w-full">
        <img src="https://www.amansala.com/images/amansala-logo-x2.png" alt="Amansala Logo" class="mx-auto h-12 mb-4" onerror="this.style.display='none'">
        <h1 class="text-3xl font-bold text-gray-800 mb-2 text-center">Retreat Resource Scheduler</h1>
        <p class="text-gray-500 mb-6 text-center">Select multiple Google Doc schedules to find booking conflicts and generate a consolidated report.</p>

        <!-- Main action button -->
        <button id="authorize_button" onclick="handleSchedulerAuthClick()" class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 transition-all duration-300 w-full text-lg shadow-md hover:shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300">
            Select Schedules & Find Conflicts
        </button>

        <!-- Status display area -->
        <div id="status" class="mt-6 text-gray-600 text-sm h-auto min-h-10 flex items-center justify-center p-2 text-center"></div>
        
        <!-- Result link area -->
        <div id="result" class="mt-4 text-center"></div>
        
        <!-- NEW: Debug Output Area -->
        <div id="debug_output" class="hidden mt-4 text-left">
            <h3 class="font-bold text-red-700">Debug Information</h3>
            <p class="text-xs text-gray-500 mb-2">The program failed to find events. This is likely due to an unexpected document format. Please copy the text below and share it for analysis.</p>
            <textarea id="debug_textarea" class="w-full h-48 p-2 border rounded bg-gray-100 font-mono text-xs" readonly></textarea>
        </div>
    </div>

    <!-- Google API Scripts -->
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiSchedulerLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisSchedulerLoaded()"></script>

    <script type="text/javascript">
    // IIFE to create a private scope and prevent conflicts with other scripts.
    (function() {
        // --- IMPORTANT: CONFIGURATION ---
        const API_KEY = 'AIzaSyD_2KFWZ-r6D3wm_1KVt0gvy8WkeLGUXcE';
        const CLIENT_ID = '5238753048-sedi66kvp746e28avm70i181mom2as3h.apps.googleusercontent.com';
        const APP_ID = CLIENT_ID.split('-')[0];
        const SCOPES = 'https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/documents';

        let tokenClient;
        let gapiInited = false;
        let gisInited = false;
        window.lastExtractedText = ''; // Variable to hold text for debugging

        // --- GOOGLE API INITIALIZATION ---
        window.gapiSchedulerLoaded = function() {
            gapi.load('client:picker', initializeGapiClient);
        }

        async function initializeGapiClient() {
            await gapi.client.init({
                apiKey: API_KEY,
                discoveryDocs: [
                    "https://docs.googleapis.com/$discovery/rest?version=v1",
                    "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"
                ],
            });
            gapiInited = true;
            maybeEnableButtons();
        }

        window.gisSchedulerLoaded = function() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: '', 
            });
            gisInited = true;
            maybeEnableButtons();
        }

        function maybeEnableButtons() {
            if (gapiInited && gisInited) {
                document.getElementById('authorize_button').style.visibility = 'visible';
            }
        }
        
        window.handleSchedulerAuthClick = function() {
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    throw (resp);
                }
                setStatus('Authentication successful. Opening file picker...');
                createPicker();
            };

            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({prompt: 'consent'});
            } else {
                tokenClient.requestAccessToken({prompt: ''});
            }
        }

        function createPicker() {
            const view = new google.picker.View(google.picker.ViewId.DOCS);
            view.setMimeTypes("application/vnd.google-apps.document");
            const picker = new google.picker.PickerBuilder()
                .enableFeature(google.picker.Feature.MULTISELECT_ENABLED)
                .setAppId(APP_ID)
                .setOAuthToken(gapi.client.getToken().access_token)
                .addView(view)
                .setDeveloperKey(API_KEY)
                .setCallback(pickerCallback)
                .build();
            picker.setVisible(true);
        }

        // --- CORE LOGIC ---

        async function pickerCallback(data) {
            if (data.action === google.picker.Action.PICKED) {
                const fileIds = data.docs.map(doc => doc.id);
                setStatus('Documents selected. Processing...');
                document.getElementById('result').innerHTML = '';
                
                try {
                    let allEvents = [];
                    let combinedTextForDebug = '';
                    setStatus(`Reading ${fileIds.length} documents...`);
                    
                    for (const fileId of fileIds) {
                        const doc = await fetchDocContent(fileId);
                        const { events, fullText } = parseScheduleContent(doc);
                        allEvents.push(...events);
                        combinedTextForDebug += `--- DOC ID: ${fileId} ---\n${fullText}\n\n`;
                    }
                    window.lastExtractedText = combinedTextForDebug;
                    
                    if (allEvents.length === 0) {
                        throw new Error("Could not parse any events. Please check the document format.");
                    }

                    setStatus('Detecting conflicts...');
                    const eventsWithConflicts = detectConflicts(allEvents);

                    setStatus('Creating Google Doc report...');
                    const reportDoc = await createConflictReportDoc(eventsWithConflicts);
                    
                    setStatus('Report created successfully!', 'success');
                    const reportUrl = `https://docs.google.com/document/d/${reportDoc.documentId}`;
                    displayResultLink(reportUrl);

                } catch (error) {
                    console.error('Error during processing:', error);
                    const errorMessage = error.result ? error.result.error.message : (error.message || JSON.stringify(error));
                    setStatus(`Error: ${errorMessage}`, 'error');
                    if (error.message.includes("Could not parse")) {
                         document.getElementById('debug_textarea').value = window.lastExtractedText;
                         document.getElementById('debug_output').classList.remove('hidden');
                    }
                }
            }
        }
        
        async function fetchDocContent(fileId) {
            const response = await gapi.client.docs.documents.get({
                documentId: fileId,
            });
            return response.result;
        }

        function parseScheduleContent(doc) {
            let fullText = '';
            doc.body.content.forEach(element => {
                if (element.paragraph) {
                    element.paragraph.elements.forEach(el => {
                        if (el.textRun) {
                            fullText += el.textRun.content;
                        }
                    });
                }
            });

            const events = [];
            const lines = fullText.split('\n');
            let currentRetreat = doc.title;
            let currentDate = '';
            
            const knownResources = ["Grande", "Chica", "Beachfront", "Rooftop", "Tulum Ruins", "Temazcal", "Gran Cenote", "Cenote", "Mangrove Tour", "Icebath", "Mayan Clay", "Salsa Class"];
            const resourceRegex = new RegExp(`\\b(${knownResources.join('|')})\\b`, 'i');
            
            const retreatNameMatch = fullText.match(/(.*)\s*\|\s*(\w+\s+\d{1,2}(?:st|nd|rd|th)?\s*-\s*\d{1,2}(?:st|nd|rd|th)?)/);
            if (retreatNameMatch && retreatNameMatch[1].length < 100) {
                currentRetreat = retreatNameMatch[1].trim();
            }

            lines.forEach(line => {
                line = line.trim();
                if (!line) return;

                const dateMatch = line.match(/^(?:Mon|Tues|Wed|Thurs|Fri|Sat|Sun|Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday)\w*\s*\|?\s*(\w+\s+\d{1,2})/i);
                if (dateMatch) {
                    const monthAndDay = dateMatch[1];
                    const year = new Date().getFullYear();
                    const parsedDate = new Date(`${monthAndDay} ${year}`);
                    if (!isNaN(parsedDate)) {
                        const month = (parsedDate.getMonth() + 1).toString().padStart(2, '0');
                        const day = parsedDate.getDate().toString().padStart(2, '0');
                        currentDate = `${year}-${month}-${day}`;
                    }
                    return; 
                }

                const timeRegex = /(\d{1,2}:\d{2})\s*(?:-\s*(\d{1,2}:\d{2}))?/;
                const timeMatch = line.match(timeRegex);
                if (timeMatch && currentDate) {
                    let startTime = timeMatch[1];
                    let endTime = timeMatch[2];
                    let description = line.replace(timeRegex, '').trim();
                    
                    if (!endTime) {
                        let start = new Date(`${currentDate}T${startTime}`);
                        if(!isNaN(start)){
                            start.setHours(start.getHours() + 1);
                            endTime = start.toTimeString().substring(0, 5);
                        } else {
                            endTime = startTime; 
                        }
                    }

                    let resource = 'TBD';
                    const resourceMatch = description.match(resourceRegex) || line.match(resourceRegex);
                    if (resourceMatch) {
                        resource = resourceMatch[0];
                        description = description.replace(resource, '').replace(/\|/g, '').replace(/\//g, ' ').trim();
                    }
                    
                    description = description.replace(/^[:-\s|]+/, '').trim();
                    const originalLineForReport = `${startTime} - ${endTime} | ${description}`;

                    events.push({
                        date: currentDate,
                        startTime: startTime,
                        endTime: endTime,
                        resource: resource,
                        retreat: currentRetreat,
                        originalLine: originalLineForReport,
                        isConflict: false
                    });
                }
            });

            return { events, fullText };
        }


        function detectConflicts(allEvents) {
            allEvents.sort((a, b) => {
                const dateA = new Date(`${a.date}T${a.startTime}`);
                const dateB = new Date(`${b.date}T${b.startTime}`);
                return dateA - dateB;
            });

            for (let i = 0; i < allEvents.length; i++) {
                for (let j = i + 1; j < allEvents.length; j++) {
                    const eventA = allEvents[i];
                    const eventB = allEvents[j];

                    if (eventA.date === eventB.date && eventA.resource.toLowerCase() === eventB.resource.toLowerCase()) {
                         try {
                            const startA = new Date(`${eventA.date}T${eventA.startTime}`);
                            const endA = new Date(`${eventA.date}T${eventA.endTime}`);
                            const startB = new Date(`${eventB.date}T${eventB.startTime}`);
                            const endB = new Date(`${eventB.date}T${eventB.endTime}`);
                            
                            if (!isNaN(startA) && !isNaN(endA) && !isNaN(startB) && !isNaN(endB)) {
                                if (startA < endB && startB < endA) {
                                    eventA.isConflict = true;
                                    eventB.isConflict = true;
                                    
                                    const overlapStart = startA > startB ? startA : startB;
                                    const overlapEnd = endA < endB ? endA : endB;
                                    const formatTime = (date) => date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                                    
                                    const conflictMessage = `⚠️ OVERLAP: ${eventA.resource} is double-booked from ${formatTime(overlapStart)} to ${formatTime(overlapEnd)}.`;
                                    eventA.conflictMessage = conflictMessage;
                                    eventB.conflictMessage = conflictMessage;
                                }
                            }
                        } catch (e) {
                            console.error("Could not parse date for conflict detection:", e);
                        }
                    }
                }
            }
            return allEvents;
        }

        async function createConflictReportDoc(events) {
            const docTitle = `Consolidated Resource Schedule - ${new Date().toLocaleDateString()}`;
            const createResponse = await gapi.client.docs.documents.create({
                title: docTitle
            });
            const documentId = createResponse.result.documentId;

            let requests = [];
            let currentIndex = 1;
            
            const titleText = "Retreat Resource Schedule\n\n";
            requests.push({ insertText: { location: { index: 1 }, text: titleText } });
            requests.push({ updateParagraphStyle: { range: { startIndex: 1, endIndex: titleText.length }, paragraphStyle: { namedStyleType: 'TITLE' }, fields: 'namedStyleType' } });
            currentIndex += titleText.length;

            let currentDate = null;

            for (let i = 0; i < events.length; i++) {
                const event = events[i];

                if (event.date !== currentDate) {
                    currentDate = event.date;
                    const dateObj = new Date(currentDate + "T00:00:00");
                    const dateString = dateObj.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                    const dateText = `${dateString}\n`;

                    requests.push({ insertText: { location: { index: currentIndex }, text: dateText } });
                    requests.push({ updateParagraphStyle: { range: { startIndex: currentIndex, endIndex: currentIndex + dateText.length }, paragraphStyle: { namedStyleType: 'HEADING_1' }, fields: 'namedStyleType' } });
                    currentIndex += dateText.length;
                }

                const eventText = `• ${event.originalLine} | ${event.retreat}\n`;
                requests.push({ insertText: { location: { index: currentIndex }, text: eventText } });

                if (event.isConflict) {
                    requests.push({ updateTextStyle: { range: { startIndex: currentIndex, endIndex: currentIndex + eventText.length }, textStyle: { foregroundColor: { color: { rgbColor: { red: 1.0, green: 0.0, blue: 0.0 } } } }, fields: 'foregroundColor' } });
                }
                currentIndex += eventText.length;
                
                const isLastEvent = i === events.length - 1;
                const nextEventIsDifferent = !isLastEvent && events[i+1].conflictMessage !== event.conflictMessage;

                if (event.isConflict && (isLastEvent || nextEventIsDifferent)) {
                    const conflictText = `${event.conflictMessage}\n\n`;
                    requests.push({ insertText: { location: { index: currentIndex }, text: conflictText } });
                    requests.push({ updateTextStyle: { range: { startIndex: currentIndex, endIndex: currentIndex + conflictText.length }, textStyle: { bold: true }, fields: 'bold' } });
                    currentIndex += conflictText.length;
                }
            }

            await gapi.client.docs.documents.batchUpdate({
                documentId: documentId,
                resource: { requests: requests }
            });

            return createResponse.result;
        }

        // --- UI HELPER FUNCTIONS ---

        function setStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.innerText = message;
            statusEl.classList.remove('text-green-600', 'text-red-600', 'text-gray-600');
            if (type === 'success') {
                statusEl.classList.add('text-green-600');
                document.getElementById('debug_output').classList.add('hidden');
            } else if (type === 'error') {
                statusEl.classList.add('text-red-600');
            } else {
                statusEl.classList.add('text-gray-600');
                document.getElementById('debug_output').classList.add('hidden');
            }
        }

        function displayResultLink(url) {
            const resultEl = document.getElementById('result');
            resultEl.innerHTML = `
                <a href="${url}" target="_blank" class="inline-block bg-green-100 text-green-800 font-semibold py-2 px-4 rounded-lg border border-green-300 hover:bg-green-200 transition-all">
                    Open Your New Google Doc Report
                </a>
            `;
        }
    })(); // End of the IIFE wrapper
    </script>
</body>
</html>




